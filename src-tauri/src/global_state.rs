use std::path::PathBuf;

use anyhow::{anyhow, bail, Result};
use crossbeam::channel::{Receiver, Sender};
use ndarray::{ArcArray2, Array2};
use tracing::{error, warn};

use crate::{
    daq::{self, DaqData, DaqMeta, InterpMeta, InterpMethod, Interpolator},
    event::{Event, Responder},
    setting::{SettingStorage, SqliteSettingStorage},
    video::VideoMeta,
};

const SQLITE_FILEPATH: &str = "./var/db.sqlite3";

struct GlobalState<S: SettingStorage> {
    setting_storage: S,
    event_sender: Sender<Event>,
    daq_data: Option<DaqData>,
}

pub fn main_loop(event_sender: Sender<Event>, event_receiver: Receiver<Event>) {
    let setting_storage = SqliteSettingStorage::new(SQLITE_FILEPATH);
    let mut global_state = GlobalState::new(setting_storage, event_sender);
    for event in event_receiver {
        if let Err(e) = global_state.handle_event(event) {
            error!(?e);
        }
    }
}

impl<S: SettingStorage> GlobalState<S> {
    fn new(setting_storage: S, event_sender: Sender<Event>) -> Self {
        Self {
            setting_storage,
            event_sender,
            daq_data: None,
        }
    }

    /// `handle_event` keeps receiving Frontend messages and computation results, then
    /// make decision what to do next based on the current global state. It should return
    /// very fast and all time-consuming tasks should be executed in other threads
    /// and send back results asynchronously by `event_sender`.
    ///
    /// There are two types of handlers for different kinds of events:
    /// - Return a `Result`, then caller will send the result. For fast handlers which
    /// can be executed in the same thread.
    /// - Take the `responder` and return nothing. The `responder` will be passed all the
    /// way down to other threads and used to send the result.
    fn handle_event(&mut self, event: Event) -> Result<()> {
        use Event::*;
        match event {
            // Event triggered by Frontend.
            GetVideoMeta { responder } => responder.respond(self.get_video_meta()),
            SetVideoPath {
                video_path,
                responder,
            } => self.set_video_path(video_path, responder),
            GetDaqMeta { responder } => responder.respond(self.get_daq_meta()),
            SetDaqPath {
                daq_path,
                responder,
            } => self.set_daq_path(daq_path, responder),
            GetDaqRaw { responder } => responder.respond(self.get_daq_raw()),
            SetInterpMethod {
                interp_method: interpolation_method,
                responder,
            } => self.set_interp_method(interpolation_method, responder),
            InterpSingleFrame {
                frame_index,
                responder,
            } => self.interp_single_frame(frame_index, responder),

            // Event generated by async task.
            ReadDaq { daq_meta, daq_raw } => self.on_event_read_daq(daq_meta, daq_raw)?,
            Interp { interpolator } => self.on_event_interp(interpolator)?,
        }

        Ok(())
    }

    fn get_video_meta(&self) -> Result<VideoMeta> {
        todo!()
    }

    fn set_video_path(&self, _video_path: PathBuf, _responder: Responder<()>) {
        todo!()
    }

    fn get_daq_meta(&self) -> Result<DaqMeta> {
        let daq_path = self.setting_storage.daq_path()?;
        let daq_data = self.daq_data()?;
        if daq_data.daq_meta().path != daq_path {
            warn!("new daq not loaded yet, return old data");
        }

        Ok(daq_data.daq_meta().clone())
    }

    fn set_daq_path(&self, daq_path: PathBuf, responder: Responder<()>) {
        if let Err(e) = self.setting_storage.set_daq_path(&daq_path) {
            responder.respond_err(e);
            return;
        }

        let event_sender = self.event_sender.clone();
        std::thread::spawn(move || match make_event_read_daq(daq_path) {
            Ok(event) => {
                event_sender.send(event).unwrap();
                responder.respond_ok(());
            }
            Err(e) => responder.respond_err(e),
        });
    }

    fn get_daq_raw(&self) -> Result<ArcArray2<f64>> {
        self.setting_storage.daq_path()?;
        Ok(self.daq_data()?.daq_raw())
    }

    fn set_interp_method(&self, interp_method: InterpMethod, responder: Responder<()>) {
        let daq_raw = match self.daq_data() {
            Ok(daq_data) => daq_data.daq_raw(),
            Err(e) => {
                responder.respond_err(e);
                return;
            }
        };

        let interp_meta = match self.setting_storage.interp_meta() {
            Ok(mut interp_meta) => {
                if interp_meta.interp_method == interp_method {
                    responder.respond_ok(());
                    return;
                }
                interp_meta.interp_method = interp_method;
                interp_meta
            }
            Err(e) => {
                responder.respond_err(e);
                return;
            }
        };

        if let Err(e) = self.setting_storage.set_interp_method(interp_method) {
            responder.respond_err(e);
            return;
        }

        let event_sender = self.event_sender.clone();
        std::thread::spawn(move || match make_event_interp(interp_meta, daq_raw) {
            Ok(event) => {
                event_sender.send(event).unwrap();
                responder.respond_ok(());
            }
            Err(e) => responder.respond_err(e),
        });
    }

    fn interp_single_frame(&self, frame_index: usize, responder: Responder<Array2<f64>>) {
        match self.interpolator() {
            Ok(interpolator) => {
                std::thread::spawn(
                    move || match interpolator.interp_single_frame(frame_index) {
                        Ok(temp2) => responder.respond_ok(temp2),
                        Err(e) => responder.respond_err(e),
                    },
                );
            }
            Err(e) => responder.respond_err(e),
        }
    }

    fn on_event_read_daq(&mut self, daq_meta: DaqMeta, daq_raw: ArcArray2<f64>) -> Result<()> {
        if self.setting_storage.daq_path()? != daq_meta.path {
            bail!("daq path changed");
        }

        self.daq_data = Some(DaqData::new(daq_meta, daq_raw));
        self.reconcile();

        Ok(())
    }

    fn on_event_interp(&mut self, interpolator: Interpolator) -> Result<()> {
        if &self.setting_storage.interp_meta()? != interpolator.meta() {
            bail!("interp meta changed, abort this result");
        }
        self.daq_data_mut()?.set_interpolator(interpolator)
    }

    fn reconcile(&mut self) {
        todo!()
    }

    fn daq_data(&self) -> Result<&DaqData> {
        self.daq_data
            .as_ref()
            .ok_or_else(|| anyhow!("daq not loaded yet"))
    }

    fn daq_data_mut(&mut self) -> Result<&mut DaqData> {
        self.daq_data
            .as_mut()
            .ok_or_else(|| anyhow!("daq not loaded yet"))
    }

    fn interpolator(&self) -> Result<Interpolator> {
        Ok(self
            .daq_data()?
            .interpolator()
            .ok_or_else(|| anyhow!("daq not loaded yet"))?
            .clone())
    }
}

fn make_event_read_daq(daq_path: PathBuf) -> Result<Event> {
    let (daq_meta, daq_raw) = daq::read_daq(daq_path)?;
    Ok(Event::ReadDaq {
        daq_meta,
        daq_raw: daq_raw.into_shared(),
    })
}

fn make_event_interp(interp_meta: InterpMeta, daq_raw: ArcArray2<f64>) -> Result<Event> {
    let interpolator = daq::interp(interp_meta, daq_raw)?;
    Ok(Event::Interp { interpolator })
}
